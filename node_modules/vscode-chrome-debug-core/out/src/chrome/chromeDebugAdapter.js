/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/

var vscode_debugadapter_1 = require('vscode-debugadapter');
var chromeConnection_1 = require('./chromeConnection');
var ChromeUtils = require('./chromeUtils');
var utils = require('../utils');
var logger = require('../logger');
// TODO: hc.jiang cannot lanuch target before implement 3.0
// TODO: Becuase require('vscode') has been added in lauch target
var launchTarget = require('../../../../../launchTarget');
var consoleHelper_1 = require('./consoleHelper');
var child_process_1 = require('child_process');
var path = require('path');
var common = require('../../../../../common');
var fs = require('fs');
var http = require('http');

var SIMULATOR_EXECUTABLE_MAC = 'nwjs.app/Contents/MacOS/nwjs';
var SIMULATOR_EXECUTABLE = (process.platform == 'win32') ? 'simulator.exe' : (process.platform == 'linux') ? 'simulator' : SIMULATOR_EXECUTABLE_MAC;

var debugType = '';
var interval;

var extensionPath = launchTarget.getExtensionPath();
var workspacePathHome = '';
// Define SDB tool's path
//var sdbRelativePath = 'tools/sdb';
var sdbRelativePath = 'tools' + path.sep + 'sdb';
var SPACE = ' ';
var sdbToolname = (process.platform == 'win32') ? 'sdb.exe' : 'sdb';
var sdbFolder = (process.platform == 'win32') ? 'win' : (process.platform == 'linux') ? 'linux' : 'mac';

var sdbAbsolutePath = '\"' + extensionPath + path.sep + sdbRelativePath + path.sep + sdbFolder + path.sep + sdbToolname + '\"';
var SDB_COMMAND_CAT = 'capability';
var SDB_OPT_SERIAL = '';

var startTime ;


/**
   Debug
**/
var ENUM_DEBUG_MODE = {
    'TIZEN_TV': 0,                       // Run on TV 2.4
    'WEB_SIMULATOR': 1,                  // Debug on TV 3.0
    'TV_EMULATOR': 2                     // Web Inspector Debug on TV
};
exports.ENUM_DEBUG_MODE = ENUM_DEBUG_MODE;
var debugTargetMode = ENUM_DEBUG_MODE.WEB_SIMULATOR;

var ChromeDebugAdapter = (function () {

    function ChromeDebugAdapter() {
        this._variableHandles = new vscode_debugadapter_1.Handles();
        this._overlayHelper = new utils.DebounceHelper(/*timeoutMs=*/ 200);
        this.clearEverything();
    }

    Object.defineProperty(ChromeDebugAdapter.prototype, 'paused', {
        get: function () {
            return !!this._currentStack;
        },
        enumerable: true,
        configurable: true
    });
 
    ChromeDebugAdapter.prototype.clearTargetContext = function () {
        this._scriptsById = new Map();
        this._committedBreakpointsByUrl = new Map();
        this._setBreakpointsRequestQ = Promise.resolve();
        this.fireEvent(new vscode_debugadapter_1.Event('clearTargetContext'));
    };

    ChromeDebugAdapter.prototype.clearClientContext = function () {
        this._clientAttached = false;
        this.fireEvent(new vscode_debugadapter_1.Event('clearClientContext'));
    };

    ChromeDebugAdapter.prototype.registerEventHandler = function (eventHandler) {
        this._eventHandler = eventHandler;
    };

    ChromeDebugAdapter.prototype.initialize = function (args) {
        // Cache to log if diagnostic logging is enabled later
        this._initArgs = args;
    };

    ChromeDebugAdapter.prototype.launch = function (args) {

        var _this = this;
        this.initializeLogging('launch', args);

        this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Start debug! \n', 'stdout'));

        var launchUrl;
        if (args.file) {
            //launchUrl = utils.pathToFileURL(args.file);

            var workspacePath = path.dirname(args.file);
            var startHtml = 'index.html';
            var configFilePath = workspacePath + path.sep + 'config.xml';

            // Check if start html set
            var configuredHtml = common.getConfStartHtml(configFilePath);
            if (configuredHtml != '') {
                startHtml = configuredHtml;
            }

            var fileUrl = workspacePath + path.sep + startHtml;

            if (!fs.existsSync(fileUrl)) {
                var wrongApp = 'It is not a standard tizen web app, so can not debug on TV Simulator!';
                this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + wrongApp + '\n', 'stderr'));
                this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Debug failed!' + '\n', 'stderr'));
                return;
            }

            launchUrl = utils.pathToFileURL(fileUrl);
            workspacePathHome = workspacePath;

        } else {
            var cannotFindLaunchFile = "Can't find file set the \"file\" field in the launch config!";
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + cannotFindLaunchFile + '\n', 'stderr'));
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Debug failed!' + '\n', 'stdout'));
            return utils.errP(cannotFindLaunchFile);
        }

        var debugIp;

        debugType = args.type;
        var workspacePath = path.dirname(args.file);

        if (args.type == 'simulator') {
            //check simulator exists
            var simulatorPath = args.runtimeLocation;
            debugTargetMode = ENUM_DEBUG_MODE.WEB_SIMULATOR;

            if (!simulatorPath) {
                var wrongSimulatorPath = "Can't find simulator - Set the \"runtimeLocation\" field in the launch config!";
                this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + wrongSimulatorPath + '\n', 'stderr'));
                this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Debug failed!' + '\n', 'stderr'));
                return utils.errP(wrongSimulatorPath);
            }

            simulatorPath = simulatorPath + path.sep + SIMULATOR_EXECUTABLE;
            if (!fs.existsSync(simulatorPath)) {
                var noSimulatorExecuteFile = "Can't find simulator executable file!";
                this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + noSimulatorExecuteFile + '\n', 'stderr'));
                this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Debug failed!' + '\n', 'stderr'));
                return utils.errP(noSimulatorExecuteFile);
            }

            // Start with remote debugging enabled
            var port = args.port || 9222;

            var runtimeArgs = '-file';
            if (args.runtimeArgs) {
                runtimeArgs = args.runtimeArgs[0];
            }

            if (runtimeArgs == '-file') {
                runtimeArgs = '-file ';
            }

            var commandArgs = '--remote-debugging-port=' + port;
            var disableInspectorArgs = '--disableInspector';

            commandArgs = commandArgs + ' ' + disableInspectorArgs + ' ' + runtimeArgs + launchUrl;

            var execCommand = '\"' + simulatorPath + '\"' + ' ' + commandArgs;

            //Judge whether simulator is running and debug port is open ,if so close simulator first 

            var that = this;

            var closeCommand = simulatorPath + ' --close';

            var simulatorFlag = utils.isRun('simulator');

            if (simulatorFlag) {

                that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Simulator is already running!' + '\n', 'stderr'));
                var aUrl = 'http://localhost:' + port;
                http.get(aUrl, function (res) {

                    resultdata = '';
                    res.on('data', function (chunk) {
                        resultdata += chunk;
                    });

                    res.on('end', function () {
                        console.log('end');

                    });
                    that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Run debug on Simulator.' + '\n', 'stdout'));
                    that.launchSimulator(execCommand);

                }).on('error', function (err) {
                    
                    that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Simulator is not running on the debug mode ,will restart it' + '\n', 'stderr'));
                    child_process_1.execSync(closeCommand);  
                    var startTime = new Date().getTime();  
                    var closeInterval = setInterval(function(){     
                        if(!utils.isRun('simulator')){
                            clearInterval(closeInterval);
                            that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Run debug on Simulator.' + '\n', 'stdout'));
                            that.launchSimulator(execCommand);
                            
                        }else if(new Date().getTime() > startTime + 30000){ // simulator close unsuccessful in 30s

                            clearInterval(closeInterval);
                            that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'The simulator process is not quit normally, please check.' + '\n', 'stderr'));
                            return utils.errP('The simulator process is not quit normally, please check.');
                        }
                        
                    }, 1000);             

                });
            } else {
                that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Run debug on Simulator.' + '\n', 'stdout'));
                that.launchSimulator(execCommand);
            }

            debugIp = '127.0.0.1:' + port;

        } else if (args.type == 'tizentv') {

            debugTargetMode = ENUM_DEBUG_MODE.TIZEN_TV;

            var launchIp = args.targetIp + ':26101';           

            // Validate     
            if (!this.preDebug(launchIp))
            {
                return utils.errP('The target Tizen version cannot support debug!');
            }

            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Launching App on Tizen TV ......'+'\n', 'stdout'));
            var buildPackage = require('../../../../../buildPackage');
            buildPackage.prepareBuildForDebug(workspacePath);
            //this.fireEvent(new vscode_debugadapter_1.OutputEvent('Launch... 50%', 'stdout'));
            launchTarget.prepareInstallForDebug(workspacePath, launchIp);
            //this.fireEvent(new vscode_debugadapter_1.OutputEvent('Launch... 80%' + '\n', 'stdout'));
            debugIp = args.targetIp + ':7011';

            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Run Debug on Tizen TV.' + '\n', 'stdout'));
            interval = setInterval(function () {
                var devicestatus = launchTarget.getDeviceStatus(args.targetIp);
                if (!devicestatus) {
                    _this.terminateSession();
                }
            }, 1000);

        } else if (args.type == 'emulator') {

            debugTargetMode = ENUM_DEBUG_MODE.TV_EMULATOR;

            //var launchIp = args.targetIp;
            var launchIp = 'emulator-26101';

            // Validate  
            try{   
                if (!this.preDebug(launchIp))
                {
                //this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'this.preDebug return ......' + '\n', 'stdout'));
                return utils.errP('The target Tizen version cannot support debug!');
                }
            }catch(e)
            {
                return utils.errP('There is no TV Emulator running instance, please check the Emulator Manager and ensure at least one running emulator instance.');
            }
        

            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Launching App on Emulator ......' + '\n', 'stdout'));
            var buildPackage = require('../../../../../buildPackage');
            //this.fireEvent(new vscode_debugadapter_1.OutputEvent('Launch... 50%', 'stdout'));
            buildPackage.prepareBuildForDebug(workspacePath);
            //this.fireEvent(new vscode_debugadapter_1.OutputEvent('Launch... 80%' + '\n', 'stdout'));

            var launchEmulatorApp = require('../../../../../launchEmulatorApp');
            launchEmulatorApp.prepareInstallForDebug(workspacePath);
            debugIp = '127.0.0.1' + ':7011';

            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Run Debug on Emulator.' + '\n', 'stdout'));
            interval = setInterval(function () {

                var devicestatus = launchTarget.getDeviceStatus('emulator');
                if (!devicestatus) {
                    _this.terminateSession();
                }

            }, 1000);
        }

        this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Send debug request to target.' + '\n', 'stdout'));
        this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Preparing the debug URL ......'  + '\n', 'stdout'));
        startTime = new Date().getTime(); 
        return this.seqRequest(debugIp, launchUrl, false);
    };

    ChromeDebugAdapter.prototype.launchSimulator = function (launchCommand) {
 
        var that = this;
        that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Debug on Simulator Command:' + launchCommand + '\n', 'stdout'));

        child_process_1.exec(launchCommand, function(err, stdout, stderr){

            if (err){         
                that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Debug on Simulator fail:' + err.message + '\n', 'stderr'));   
                throw err;
            } 
            else {
            } 
        });
    };

    ChromeDebugAdapter.prototype.seqRequest = function (debugIp, launchUrl, flag) {
        var timeoutEventId;
        var aUrl = 'http://' + debugIp + '/json';
        var that = this;
        var req = http.get(aUrl, function (res) {
            resultdata = '';
            res.on('data', function (chunk) {
                resultdata += chunk;
            });

            res.on('end', function () {

                if (res.statusCode != 200) {
                    //that.fireEvent(new vscode_debugadapter_1.OutputEvent('...', 'stdout'));
                    that.seqRequest(debugIp, launchUrl, flag);
                } else {

                    var responseArray = JSON.parse(resultdata);
                    var pages = responseArray.filter(function (target) { return target });

                    if ((pages.length > 0) && pages[0].webSocketDebuggerUrl) {

                        if (debugType == 'simulator' && pages.length <= 1) {
                            //that.fireEvent(new vscode_debugadapter_1.OutputEvent('...', 'stdout'));
                            that.seqRequest(debugIp, launchUrl, flag);
                        } else {
                            flag = true;
                            that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'URL has been send.' + '\n', 'stdout'));
                            return that._attach(debugIp, launchUrl);
                        }

                    } else {
                        //that.fireEvent(new vscode_debugadapter_1.OutputEvent('...', 'stdout'));
                        that.seqRequest(debugIp, launchUrl, flag);
                    }

                }
            });
        });

        req.on('error', function (err) {
            var currentTime = new Date().getTime();  
            if (!flag && currentTime <startTime+60000) {
                that.seqRequest(debugIp, launchUrl, flag);
            }else{
                that.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Failed to open the debug port, You can restart your target for try !' + '\n', 'stderr'));
            }

        });

        req.on('timeout', function (err) {
            req.abort();
        });

        timeoutEventId = setTimeout(function () {
            req.emit('timeout', { message: 'Have been timeout.' });
        }, 5000);

    };

    // Get the current target version 
    ChromeDebugAdapter.prototype.preDebug = function (launchIp) {

        if (debugTargetMode == ENUM_DEBUG_MODE.TIZEN_TV)
        {
            var SDB_COMMAND_CONNECT = 'connect';
            var SDB_COMMAND_DISCONNECT = 'disconnect';

            // Try to disconnect the App at begining, for reset
            var disconnectCommand = sdbAbsolutePath + SPACE + SDB_COMMAND_DISCONNECT + SPACE + launchIp;
            child_process_1.execSync(disconnectCommand);

            // Connect to target
            var connectCommand = sdbAbsolutePath + SPACE + SDB_COMMAND_CONNECT + SPACE + launchIp;
            child_process_1.execSync(connectCommand);
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Connected to target!' + '\n', 'stdout'));
        }

        // Set the option for later commands
        SDB_OPT_SERIAL = '-s ' + launchIp;

        // Check the version of target
        var catCommand = sdbAbsolutePath + SPACE + SDB_OPT_SERIAL + SPACE + SDB_COMMAND_CAT;
        var isTizenVersion3_0 = common.getTargetVersion(catCommand);

        if (isTizenVersion3_0 == '2.4') {

            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'The Tizen version does not support the debug mode!' + '\n', 'stderr'));
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Debug failed!' + '\n', 'stderr'));
            return false;
        }

        var isRunningFlag = this.ifAppRunning();
        // Commented on 2017.1.6, the info has been handled in terminateApp function
        /*if (listData.length > 0)
        {*/
        // this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Start to close the running App.' + '\n', 'stdout'));
        if(isRunningFlag == true)
        {
            try{
            this.terminateApp(isRunningFlag);
            }catch(err)
            {
                return false;
            }
        }
        //this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Finish PreDebug.' + '\n', 'stdout'));

        return true;
    };

    ChromeDebugAdapter.prototype.ifAppRunning = function () {

        // Get app ID
        var configFilePath = workspacePathHome + path.sep + 'config.xml';
        var appId = common.getConfAppID(configFilePath);
        this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'The app id is ' + appId + '\n', 'stdout'));
        var appRandomId = appId.substring(0, 10);

        // Get process ID by app ID
        //var WAS_COMMAD_PS = 'shell pgrep';
        var WAS_COMMAD_PS = 'shell 0 runcheck';
        var psCommand = sdbAbsolutePath + SPACE + SDB_OPT_SERIAL + SPACE + WAS_COMMAD_PS + SPACE + appRandomId;
        this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Checking running processing' + '\n', 'stdout'));
        //this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'psCommand: ' + psCommand + '\n', 'stdout'));
        var listData = child_process_1.execSync(psCommand);
        if(listData.indexOf(appRandomId+' is Running')>=0){
            return true;
        }else{
            return false;
        }
       
    };

    ChromeDebugAdapter.prototype.terminateApp = function (flag) {

        if (flag) {
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Start to close the running App!' + '\n', 'stdout'));
            var configFilePath = workspacePathHome + path.sep + 'config.xml';
            var appId = common.getConfAppID(configFilePath);

            // Kill the App process after stop debug
            var WAS_COMMAD_KILL = 'shell 0 was_kill';
            
            var killCommand = sdbAbsolutePath + SPACE + SDB_OPT_SERIAL + SPACE + WAS_COMMAD_KILL + SPACE + appId;
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'killcommand: ' + killCommand + '\n', 'stdout'));
            child_process_1.execSync(killCommand);
            // Sleep for 0.5s to wait termination process end, and then check the status.(especially for MAC/Linux)
            // Because setTimeout() functions is unwork here, so just sleep 0.5s temporarily
            common.sleepMs(500);
            var isRunningFlag = this.ifAppRunning();
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'App running status: ' + isRunningFlag+ '\n', 'stdout'));
            if (isRunningFlag)
            {
                var cannotQuit = 'WARNNING: App cannot be quited when stop debug, please quit it manually!';
                this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + cannotQuit + '\n', 'stderr'));
                return utils.errP(cannotQuit);
            }else{
                this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Terminate App successfully!' + '\n', 'stdout'));
            }


        } else {

            var cannotClose = "There's no running App!";
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + cannotClose + '\n', 'stdout'));
            return utils.errP(cannotClose);
        }

    };

    ChromeDebugAdapter.prototype.attach = function (args) {
        if (args.port == null) {
            return utils.errP('The "port" field is required in the attach config.');
        }
        this.initializeLogging('attach', args);
        return this._attach(args.port, args.url);
    };

    ChromeDebugAdapter.prototype.initializeLogging = function (name, args) {

        if (args.diagnosticLogging && !this._isLoggingInitialized) {
            logger.enableDiagnosticLogging();
            logger.log('initialize(' + JSON.stringify(this._initArgs) + ')');
            logger.log(name + '(' + JSON.stringify(args) + ')');
            if (!args.webRoot) {
                logger.log('WARNING: "webRoot" is not set - if resolving sourcemaps fails, please set the "webRoot" property in the launch config.');
            }
            this._isLoggingInitialized = true;
        }
    };

    /**
     * Chrome is closing, or error'd somehow, stop the debug session
     */
    ChromeDebugAdapter.prototype.terminateSession = function () {

        if (interval) {
            clearInterval(interval);
        }
        this.fireEvent(new vscode_debugadapter_1.TerminatedEvent());
   
        this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Session has been closed' + '\n', 'stdout'));
        this.clearEverything();
    };

    ChromeDebugAdapter.prototype.clearEverything = function () {

        this.clearClientContext();
        this.clearTargetContext();
        this._chromeProc = null;

        if (this._chromeConnection) {
            this._chromeConnection.close();
            this._chromeConnection = null;
        }
    };

    ChromeDebugAdapter.prototype._attach = function (port, url) {

        this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Debugger is running!' + '\n', 'stdout'));
        if (debugTargetMode == ENUM_DEBUG_MODE.TIZEN_TV || debugTargetMode == ENUM_DEBUG_MODE.TV_EMULATOR)
        {
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'WARNNING: To debug App properly, please close the RWI pop-up if it is on top of App! ' + '\n', 'stderr'));
        }

        var _this = this;
        // ODP client is attaching - if not attached to the chrome target, create a connection and attach
        this._clientAttached = true;
        if (!this._chromeConnection) {
            this._chromeConnection = new chromeConnection_1.ChromeConnection();
            this._chromeConnection.on('Debugger.paused', function (params) { return _this.onDebuggerPaused(params); });
            this._chromeConnection.on('Debugger.resumed', function () { return _this.onDebuggerResumed(); });
            this._chromeConnection.on('Debugger.scriptParsed', function (params) { return _this.onScriptParsed(params); });
            this._chromeConnection.on('Debugger.globalObjectCleared', function () { return _this.onGlobalObjectCleared(); });
            this._chromeConnection.on('Debugger.breakpointResolved', function (params) { return _this.onBreakpointResolved(params); });
            this._chromeConnection.on('Console.messageAdded', function (params) { return _this.onConsoleMessage(params); });
            this._chromeConnection.on('Inspector.detached', function () { return _this.terminateSession(); });
            this._chromeConnection.on('close', function () { return _this.terminateSession(); });
            this._chromeConnection.on('error', function () { return _this.terminateSession(); });
            return this._chromeConnection.attach(port, url)
                .then(function () { return _this.fireEvent(new vscode_debugadapter_1.InitializedEvent()); }, function (e) {
                    _this.clearEverything();
                    return utils.errP(e);
                });
        }
        else {
            return Promise.resolve();
        }
    };

    ChromeDebugAdapter.prototype.fireEvent = function (event) {
        if (this._eventHandler) {
            this._eventHandler(event);
        }
    };

    /**
     * e.g. the target navigated
     */
    ChromeDebugAdapter.prototype.onGlobalObjectCleared = function () {
        this.clearTargetContext();
    };

    ChromeDebugAdapter.prototype.onDebuggerPaused = function (notification) {
        var _this = this;
        this._overlayHelper.doAndCancel(function () { return _this._chromeConnection.page_setOverlayMessage(ChromeDebugAdapter.PAGE_PAUSE_MESSAGE); });
        this._currentStack = notification.callFrames;
        // We can tell when we've broken on an exception. Otherwise if hitBreakpoints is set, assume we hit a
        // breakpoint. If not set, assume it was a step. We can't tell the difference between step and 'break on anything'.
        var reason;
        var exceptionText;
        if (notification.reason === 'exception') {
            reason = 'exception';
            if (notification.data && this._currentStack.length) {
                // Insert a scope to wrap the exception object. exceptionText is unused by Code at the moment.
                var remoteObjValue = ChromeUtils.remoteObjectToValue(notification.data, /*stringify=*/ false);
                var scopeObject = void 0;
                if (remoteObjValue.variableHandleRef) {
                    // If the remote object is an object (probably an Error), treat the object like a scope.
                    exceptionText = notification.data.description;
                    scopeObject = notification.data;
                }
                else {
                    // If it's a value, use a special flag and save the value for later.
                    exceptionText = notification.data.value;
                    scopeObject = { objectId: ChromeDebugAdapter.EXCEPTION_VALUE_ID };
                    this._exceptionValueObject = notification.data;
                }
                this._currentStack[0].scopeChain.unshift({ type: 'Exception', object: scopeObject });
            }
        }
        else {
            reason = (notification.hitBreakpoints && notification.hitBreakpoints.length) ? 'breakpoint' : 'step';
        }
        this.fireEvent(new vscode_debugadapter_1.StoppedEvent(reason, /*threadId=*/ ChromeDebugAdapter.THREAD_ID, exceptionText));
    };

    ChromeDebugAdapter.prototype.onDebuggerResumed = function () {
        var _this = this;
        this._overlayHelper.wait(function () { return _this._chromeConnection.page_clearOverlayMessage(); });
        this._currentStack = null;
        if (!this._expectingResumedEvent) {
            // This is a private undocumented event provided by VS Code to support the 'continue' button on a paused Chrome page
            var resumedEvent = new vscode_debugadapter_1.Event('continued', { threadId: ChromeDebugAdapter.THREAD_ID });
            this.fireEvent(resumedEvent);
        }
        else {
            this._expectingResumedEvent = false;
        }
    };

    ChromeDebugAdapter.prototype.onScriptParsed = function (script) {
        this._scriptsById.set(script.scriptId, script);
        if (!this.isExtensionScript(script)) {
            this.fireEvent(new vscode_debugadapter_1.Event('scriptParsed', { scriptUrl: script.url, sourceMapURL: script.sourceMapURL }));
        }
    };

    ChromeDebugAdapter.prototype.onBreakpointResolved = function (params) {
        var script = this._scriptsById.get(params.location.scriptId);
        if (!script) {
            // Breakpoint resolved for a script we don't know about
            return;
        }
        var committedBps = this._committedBreakpointsByUrl.get(script.url) || [];
        committedBps.push(params.breakpointId);
        this._committedBreakpointsByUrl.set(script.url, committedBps);
    };

    ChromeDebugAdapter.prototype.onConsoleMessage = function (params) {
        var formattedMessage = consoleHelper_1.formatConsoleMessage(params.message);
        if (formattedMessage) {
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(formattedMessage.text + '\n', formattedMessage.isError ? 'stderr' : 'stdout'));
        }
    };

    ChromeDebugAdapter.prototype.disconnect = function () {

        if (debugTargetMode == ENUM_DEBUG_MODE.TIZEN_TV || debugTargetMode == ENUM_DEBUG_MODE.TV_EMULATOR) {
            
            var isRunningFlag = this.ifAppRunning();
            this.fireEvent(new vscode_debugadapter_1.OutputEvent(`${(new Date().toLocaleTimeString())}` + ' ' + 'Check the app runing status: ' + isRunningFlag + '\n', 'stdout'));

            
            // Commented on 2017.1.6, the info has been handled in terminateApp function
            /*if (listData.length > 0)
            {*/
            if(isRunningFlag == true)
            {
                this.terminateApp(isRunningFlag); 
            }
            //}
        }

        if (this._chromeProc) {
            this._chromeProc.kill('SIGINT');
            this._chromeProc = null;
        }
        this.clearEverything();
        return Promise.resolve();
    };

    ChromeDebugAdapter.prototype.setBreakpoints = function (args) {
        var _this = this;
        var targetScriptUrl;
        if (args.source.path) {
            targetScriptUrl = args.source.path;
        }
        else if (args.source.sourceReference) {
            var targetScript = this._scriptsById.get(sourceReferenceToScriptId(args.source.sourceReference));
            if (targetScript) {
                targetScriptUrl = targetScript.url;
            }
        }
        if (targetScriptUrl) {
            // DebugProtocol sends all current breakpoints for the script. Clear all scripts for the breakpoint then add all of them
            var setBreakpointsPFailOnError = this._setBreakpointsRequestQ
                .then(function () { return _this._clearAllBreakpoints(targetScriptUrl); })
                .then(function () { return _this._addBreakpoints(targetScriptUrl, args.lines, args.cols); })
                .then(function (responses) { return ({ breakpoints: _this._chromeBreakpointResponsesToODPBreakpoints(targetScriptUrl, responses, args.lines) }); });
            var setBreakpointsPTimeout = utils.promiseTimeout(setBreakpointsPFailOnError, /*timeoutMs*/ 2000, 'Set breakpoints request timed out');
            // Do just one setBreakpointsRequest at a time to avoid interleaving breakpoint removed/breakpoint added requests to Chrome.
            // Swallow errors in the promise queue chain so it doesn't get blocked, but return the failing promise for error handling.
            this._setBreakpointsRequestQ = setBreakpointsPTimeout.catch(function () { return undefined; });
            return setBreakpointsPTimeout;
        }
        else {
            return utils.errP("Can't find script for breakpoint request");
        }
    };

    ChromeDebugAdapter.prototype.setFunctionBreakpoints = function () {
        return Promise.resolve();
    };

    ChromeDebugAdapter.prototype._clearAllBreakpoints = function (url) {
        var _this = this;
        if (!this._committedBreakpointsByUrl.has(url)) {
            return Promise.resolve();
        }
        // Remove breakpoints one at a time. Seems like it would be ok to send the removes all at once,
        // but there is a chrome bug where when removing 5+ or so breakpoints at once, it gets into a weird
        // state where later adds on the same line will fail with 'breakpoint already exists' even though it
        // does not break there.
        return this._committedBreakpointsByUrl.get(url).reduce(function (p, bpId) {
            return p.then(function () { return _this._chromeConnection.debugger_removeBreakpoint(bpId); }).then(function () { });
        }, Promise.resolve()).then(function () {
            _this._committedBreakpointsByUrl.set(url, null);
        });
    };

    ChromeDebugAdapter.prototype._addBreakpoints = function (url, lines, cols) {
        var _this = this;
        // Call setBreakpoint for all breakpoints in the script simultaneously
        var responsePs = lines
            .map(function (lineNumber, i) { return _this._chromeConnection.debugger_setBreakpointByUrl(url, lineNumber, cols ? cols[i] : 0); });
        // Join all setBreakpoint requests to a single promise
        return Promise.all(responsePs);
    };

    ChromeDebugAdapter.prototype._chromeBreakpointResponsesToODPBreakpoints = function (url, responses, requestLines) {
        // Don't cache errored responses
        var committedBpIds = responses
            .filter(function (response) { return !response.error; })
            .map(function (response) { return response.result.breakpointId; });
        // Cache successfully set breakpoint ids from chrome in committedBreakpoints set
        this._committedBreakpointsByUrl.set(url, committedBpIds);
        // Map committed breakpoints to DebugProtocol response breakpoints
        return responses
            .map(function (response, i) {
                // The output list needs to be the same length as the input list, so map errors to
                // unverified breakpoints.
                if (response.error || !response.result.locations.length) {
                    return {
                        verified: false,
                        line: requestLines[i],
                        column: 0
                    };
                }
                return {
                    verified: true,
                    line: response.result.locations[0].lineNumber,
                    column: response.result.locations[0].columnNumber
                };
            });
    };

    ChromeDebugAdapter.prototype.setExceptionBreakpoints = function (args) {

        var state;
        if (args.filters.indexOf('all') >= 0) {
            state = 'all';
        }
        else if (args.filters.indexOf('uncaught') >= 0) {
            state = 'uncaught';
        }
        else {
            state = 'none';
        }
        return this._chromeConnection.debugger_setPauseOnExceptions(state)
            .then(function () { });
    };

    ChromeDebugAdapter.prototype.continue = function () {

        this._expectingResumedEvent = true;
        return this._chromeConnection.debugger_resume()
            .then(function () { });
    };

    ChromeDebugAdapter.prototype.next = function () {

        this._expectingResumedEvent = true;
        return this._chromeConnection.debugger_stepOver()
            .then(function () { });
    };

    ChromeDebugAdapter.prototype.stepIn = function () {

        this._expectingResumedEvent = true;
        return this._chromeConnection.debugger_stepIn()
            .then(function () { });
    };

    ChromeDebugAdapter.prototype.stepOut = function () {

        this._expectingResumedEvent = true;
        return this._chromeConnection.debugger_stepOut()
            .then(function () { });
    };

    ChromeDebugAdapter.prototype.pause = function () {
        return this._chromeConnection.debugger_pause()
            .then(function () { });
    };

    ChromeDebugAdapter.prototype.stackTrace = function (args) {

        var _this = this;
        // Only process at the requested number of frames, if 'levels' is specified
        var stack = this._currentStack;
        if (args.levels) {
            stack = this._currentStack.filter(function (_, i) { return i < args.levels; });
        }
        var stackFrames = stack
            .map(function (callFrame, i) {
                var script = _this._scriptsById.get(callFrame.location.scriptId);
                var line = callFrame.location.lineNumber;
                var column = callFrame.location.columnNumber;
                try {
                    // When the script has a url and isn't a content script, send the name and path fields. PathTransformer will
                    // attempt to resolve it to a script in the workspace. Otherwise, send the name and sourceReference fields.
                    var source = script.url && !_this.isExtensionScript(script) ?
                        {
                            name: path.basename(script.url),
                            path: script.url,
                            sourceReference: scriptIdToSourceReference(script.scriptId) // will be 0'd out by PathTransformer if not needed
                        } :
                        {
                            // Name should be undefined, work around VS Code bug 20274
                            name: 'eval: ' + script.scriptId,
                            sourceReference: scriptIdToSourceReference(script.scriptId)
                        };
                    // If the frame doesn't have a function name, it's either an anonymous function
                    // or eval script. If its source has a name, it's probably an anonymous function.
                    var frameName = callFrame.functionName || (script.url ? '(anonymous function)' : '(eval code)');
                    return {
                        id: i,
                        name: frameName,
                        source: source,
                        line: line,
                        column: column
                    };
                }
                catch (e) {
                    // Some targets such as the iOS simulator behave badly and return nonsense callFrames.
                    // In these cases, return a dummy stack frame
                    return {
                        id: i,
                        name: 'Unknown',
                        source: { name: 'eval:Unknown' },
                        line: line,
                        column: column
                    };
                }
            });
        return { stackFrames: stackFrames };
    };

    ChromeDebugAdapter.prototype.scopes = function (args) {

        var _this = this;
        var scopes = this._currentStack[args.frameId].scopeChain.map(function (scope, i) {
            var scopeHandle = { objectId: scope.object.objectId };
            if (i === 0) {
                // The first scope should include 'this'. Keep the RemoteObject reference for use by the variables request
                scopeHandle.thisObj = _this._currentStack[args.frameId]['this'];
            }
            return {
                name: scope.type,
                variablesReference: _this._variableHandles.create(scopeHandle),
                expensive: scope.type === 'global'
            };
        });
        return { scopes: scopes };
    };

    ChromeDebugAdapter.prototype.variables = function (args) {

        var _this = this;
        var handle = this._variableHandles.get(args.variablesReference);
        if (handle.objectId === ChromeDebugAdapter.EXCEPTION_VALUE_ID) {
            // If this is the special marker for an exception value, create a fake property descriptor so the usual route can be used
            var excValuePropDescriptor = { name: 'exception', value: this._exceptionValueObject };
            return Promise.resolve({ variables: [this.propertyDescriptorToVariable(excValuePropDescriptor)] });
        }
        else if (handle != null) {
            return Promise.all([
                // Need to make two requests to get all properties
                this._chromeConnection.runtime_getProperties(handle.objectId, /*ownProperties=*/ false, /*accessorPropertiesOnly=*/ true),
                this._chromeConnection.runtime_getProperties(handle.objectId, /*ownProperties=*/ true, /*accessorPropertiesOnly=*/ false)
            ]).then(function (getPropsResponses) {
                // Sometimes duplicates will be returned - merge all property descriptors returned
                var propsByName = new Map();
                getPropsResponses.forEach(function (response) {
                    if (!response.error) {
                        response.result.result.forEach(function (propDesc) {
                            return propsByName.set(propDesc.name, propDesc);
                        });
                    }
                });
                // Convert Chrome prop descriptors to DebugProtocol vars, sort the result
                var variables = [];
                propsByName.forEach(function (propDesc) { return variables.push(_this.propertyDescriptorToVariable(propDesc)); });
                variables.sort(function (var1, var2) { return var1.name.localeCompare(var2.name); });
                // If this is a scope that should have the 'this', prop, insert it at the top of the list
                if (handle.thisObj) {
                    variables.unshift(_this.propertyDescriptorToVariable({ name: 'this', value: handle.thisObj }));
                }
                return { variables: variables };
            });
        }
        else {
            return Promise.resolve(undefined);
        }
    };
    ChromeDebugAdapter.prototype.source = function (args) {
        return this._chromeConnection.debugger_getScriptSource(sourceReferenceToScriptId(args.sourceReference)).then(function (chromeResponse) {
            return { content: chromeResponse.result.scriptSource };
        });
    };

    ChromeDebugAdapter.prototype.threads = function () {
        return {
            threads: [
                {
                    id: ChromeDebugAdapter.THREAD_ID,
                    name: 'Thread ' + ChromeDebugAdapter.THREAD_ID
                }
            ]
        };
    };

    ChromeDebugAdapter.prototype.evaluate = function (args) {
        var _this = this;
        var evalPromise;
        if (this.paused) {
            var callFrameId = this._currentStack[args.frameId].callFrameId;
            evalPromise = this._chromeConnection.debugger_evaluateOnCallFrame(callFrameId, args.expression);
        }
        else {
            evalPromise = this._chromeConnection.runtime_evaluate(args.expression);
        }
        return evalPromise.then(function (evalResponse) {
            if (evalResponse.result.wasThrown) {
                var evalResult = evalResponse.result;
                var errorMessage = 'Error';
                if (evalResult.exceptionDetails) {
                    errorMessage = evalResult.exceptionDetails.text;
                }
                else if (evalResult.result && evalResult.result.description) {
                    errorMessage = evalResult.result.description;
                }
                return utils.errP(errorMessage);
            }
            var _a = _this.remoteObjectToValueWithHandle(evalResponse.result.result), value = _a.value, variablesReference = _a.variablesReference;
            return { result: value, variablesReference: variablesReference };
        });
    };

    ChromeDebugAdapter.prototype.propertyDescriptorToVariable = function (propDesc) {
        if (propDesc.get || propDesc.set) {
            // A property doesn't have a value here, and we shouldn't evaluate the getter because it may have side effects.
            // Node adapter shows 'undefined', Chrome can eval the getter on demand.
            return { name: propDesc.name, value: 'property', variablesReference: 0 };
        }
        else {
            var _a = this.remoteObjectToValueWithHandle(propDesc.value), value = _a.value, variablesReference = _a.variablesReference;
            return { name: propDesc.name, value: value, variablesReference: variablesReference };
        }
    };

    /**
     * Run the object through ChromeUtilities.remoteObjectToValue, and if it returns a variableHandle reference,
     * use it with this instance's variableHandles to create a variable handle.
     */
    ChromeDebugAdapter.prototype.remoteObjectToValueWithHandle = function (object) {
        var _a = ChromeUtils.remoteObjectToValue(object), value = _a.value, variableHandleRef = _a.variableHandleRef;
        var result = { value: value, variablesReference: 0 };
        if (variableHandleRef) {
            result.variablesReference = this._variableHandles.create({ objectId: variableHandleRef });
        }
        return result;
    };
    ChromeDebugAdapter.prototype.isExtensionScript = function (script) {
        return script.isContentScript || !script.url || script.url.startsWith('extensions::') || script.url.startsWith('chrome-extension://');
    };
    ChromeDebugAdapter.THREAD_ID = 1;
    ChromeDebugAdapter.PAGE_PAUSE_MESSAGE = 'Paused in Visual Studio Code';
    ChromeDebugAdapter.EXCEPTION_VALUE_ID = 'EXCEPTION_VALUE_ID';
    return ChromeDebugAdapter;
} ());
exports.ChromeDebugAdapter = ChromeDebugAdapter;
function scriptIdToSourceReference(scriptId) {
    return parseInt(scriptId, 10);
}
function sourceReferenceToScriptId(sourceReference) {
    return '' + sourceReference;
}
//# sourceMappingURL=chromeDebugAdapter.js.map
